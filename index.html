<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>만화 일정 관리</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght400;700&display=swap" rel="stylesheet"/>
  <style>
    body{font-family:'Noto Sans KR',sans-serif;background:#000;color:#fff;display:flex;justify-content:flex-start;align-items:center;min-height:100vh;padding:16px;flex-direction:column;gap:0}
    .tab-content{display:none}.tab-content.active{display:flex;flex-direction:column;flex-grow:1}
    .section-card{background:#2a2a2a;border-radius:12px;padding:20px;box-shadow:inset 0 0 10px rgba(0,0,0,.3);text-align:center;width:100%;max-width:800px}
    .notepad-tabs{display:flex;justify-content:center;align-items:center;gap:1rem;width:100%;max-width:800px}
    .notepad-tab{background:#1a1a1a;padding:8px 16px;border-radius:8px 8px 0 0;cursor:pointer;transition:.2s;font-weight:700;color:#737373;font-size:.85rem}
    .notepad-tab.active,.notepad-tab:hover{background:#2a2a2a;color:#fff}

    /* ===== 메모(내부) 탭 전용 스타일: 메인 탭(.notepad-tab)과 분리 ===== */
/* 메모 공간과 분리된 '둥근 네모' 탭 */
#notesHeaderRow{margin-top:8px;margin-bottom:8px}
#notesTabsContainer{
  justify-content:flex-start;
  align-items:center;
  gap:8px;
  padding-left:10px;
  margin-top:0;
}

.notes-tab{
  background:#3a3a3a;
  padding:8px 16px;
  border-radius:12px;
  cursor:pointer;
  transition:background .2s,color .2s,transform .15s ease;
  font-weight:700;
  color:#ddd;
  font-size:.85rem;
  position:relative;
  z-index:1;
  border:1px solid transparent;
}
.notes-tab:hover{background:#4a4a4a}
.notes-tab.active{
  background:#111;
  color:#fff;
  border-color:#2a2a2a;
  z-index:2;
}

.notes-tab.dragging{opacity:.3}
.notes-tab.placeholder{opacity:1}

/* 메모 입력 영역은 탭과 분리되게 약간 간격 */
#notesArea{margin-top:10px}

.notes-tab .tab-del{margin-left:8px;display:inline-flex;align-items:center;justify-content:center;width:18px;height:18px;border-radius:999px;background:#555;color:#fff;font-size:12px;line-height:1}

/* 아이콘 버튼 (메모 + / 편집) */

    .icon-btn{background:transparent;border:none;padding:6px;display:inline-flex;align-items:center;justify-content:center;border-radius:10px;cursor:pointer}
    .icon-btn:hover{background:rgba(255,255,255,.08)}
    .icon-btn svg{width:18px;height:18px;display:block}
    .notes-area{flex-grow:1;resize:vertical}
    textarea#notesArea::-webkit-scrollbar{width:8px;background-color:#2a2a2a;border-radius:10px}
    textarea#notesArea::-webkit-scrollbar-thumb{background-color:#555;border-radius:10px}
    .calendar-header{display:grid;grid-template-columns:repeat(7,1fr);gap:4px;margin-bottom:4px}
    .calendar-grid{display:grid;grid-template-columns:repeat(7,1fr);gap:4px}
    .day-label,.calendar-day{text-align:center;padding:8px 2px;border-radius:8px;background:#2a2a2a;position:relative;overflow:hidden;word-wrap:break-word}
    .day-label{background:#444;font-weight:700;color:#fff;font-size:.8rem;padding:8px 0}
    .calendar-day{min-height:160px;padding-top:16px;padding-left:2px;padding-right:2px;display:flex;flex-direction:column;gap:2px}
    .calendar-day.today{border:2px solid #ccc}
    .day-number{position:absolute;top:8px;left:8px;font-size:.85rem;font-weight:700;color:#aaa;z-index:10}
    .day-divider{height:1px;background:#3a3a3a;margin:18px 6px 2px;border-radius:999px;opacity:.95}
    .task-item{font-size:.85rem;padding:5px 6px;border-radius:8px;margin-top:4px;word-wrap:break-word;cursor:pointer;text-align:left}
    .task-item.custom-task{background:#4c78a8}
    .task-item.custom-task.custom-important{background:#dc2626;color:#fff}
    .task-item.custom-task.custom-family{background:#2563eb;color:#fff}
    .task-item.custom-task.custom-special{background:#16a34a;color:#fff}
    .task-item.episode-task{background:#444;color:#ddd}
    /* 완료(complete) 공통 */
    .task-item.complete{background:#888;text-decoration:line-through;color:#ccc}
    /* 커스텀(개인작업) 완료 시: 카테고리 색상보다 우선해서 회색 처리 */
    .task-item.custom-task.complete{background:#666 !important;color:#bdbdbd !important;text-decoration:line-through;opacity:.95}
    .add-task-btn{background:#666;transition:.2s}.add-task-btn:hover{background:#777;transform:scale(1.02)}
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;justify-content:center;align-items:center;z-index:1000}
    .modal-content{background:#1a1a1a;border-radius:12px;padding:24px;width:90%;max-width:500px;box-shadow:0 10px 30px rgba(0,0,0,.5);position:relative}
    .drag-area{border:2px dashed #4b4b4b;transition:all .3s ease;padding:24px}
    .drag-area.active{border-color:#6b6b6b;background-color:#2a2a2a}
    
    /* 일일 체크 버튼 그룹 (쇼츠/웹툰) 스타일 */
    .daily-check-group {
        display: flex;
        width: 100%;
        gap: 2px;
        margin-top: 2px;
    }
    .daily-check-btn {
        flex: 1;
        text-align: center;
        font-size: 0.75rem;
        padding: 4px 0;
        border-radius: 4px;
        background: #444; /* 기본 회색 */
        color: #ccc;
        cursor: pointer;
        transition: background 0.2s, color 0.2s;
        font-weight: 500;
    }
    .daily-check-btn:hover {
        opacity: 0.9;
    }
    /* 쇼츠 활성 상태: 빨강 */
    .daily-check-btn.shorts.active {
        background: #7c3aed; 
        color: white;
        font-weight: 700;
    }
    /* 웹툰 활성 상태: 노랑 */
    .daily-check-btn.webtoon.active {
        background: #f59e0b;
        color: white;
        font-weight: 700;
    }

    /* 달력 아래 일정 & 할 일 리스트 */
    .agenda-item{display:flex;align-items:center;gap:10px;background:#2a2a2a;border-radius:10px;padding:10px 10px}
    .agenda-dot{width:10px;height:10px;border-radius:999px;flex:0 0 10px}
    .agenda-date{font-size:.8rem;color:#bbb;min-width:92px}
    .agenda-text{flex:1 1 auto;word-break:break-word}
    .agenda-actions{display:flex;gap:6px;flex:0 0 auto}
    .agenda-btn{background:#3a3a3a;border-radius:10px;padding:6px 8px;font-size:.8rem;color:#fff;cursor:pointer;user-select:none}
    .agenda-btn:hover{background:#4a4a4a}
    .agenda-section-title{margin-top:10px;margin-bottom:6px;color:#ddd;font-weight:700;font-size:.9rem;opacity:.95}
    .agenda-settings-btn{display:inline-flex;align-items:center;justify-content:center;width:34px;height:30px;background:#3a3a3a;border-radius:10px;color:#fff;border:none;cursor:pointer;user-select:none}
    .agenda-settings-btn:hover{background:#4a4a4a}


    
    /* 완료된 할일(리스트): 원래처럼 '회색 + 취소선'이 확실히 보이도록 강제 */
    .agenda-item.complete{opacity:.9;background:#242424}
    .agenda-item.complete .agenda-text{color:#7a7a7a !important;text-decoration:line-through}
    .agenda-item.complete .agenda-date{color:#6b7280 !important}
/* 북마크 Masonry 레이아웃 */
    #image-grid {
        column-count: 2; /* 기본 2열 */
        column-gap: 1rem;
        margin-top: 1.5rem; /* mt-6 */
        display: block;
    }
    @media (min-width: 640px) { /* sm: 3열 */
        #image-grid { column-count: 3; }
    }
    @media (min-width: 1024px) { /* lg: 4열 */
        #image-grid { column-count: 4; }
    }

    /* 북마크 카드 스타일 */
    .bookmark-card{
        position: relative;
        transition: transform .2s ease-in-out; 
        background: #333; 
        border-radius: 8px; 
        overflow: hidden; 
        margin-bottom: 1rem; /* 세로 간격 */
        break-inside: avoid; /* 카드 분할 방지 */
        width: 100%; /* Column 아이템으로 사용 */
        display: block;
    }
    .bookmark-card:hover{transform:translateY(-5px)}
    
    /* 콘텐츠 영역: 이미지/아이콘 높이에 따라 크기 결정 */
    .bookmark-card .content {
        display: block; 
        width: 100%;
        height: auto;
        overflow: hidden;
        background-color: #1a1a1a;
        /* 링크나 동영상 썸네일이 없을 때 최소 높이 보장 */
        min-height: 80px; 
        position: relative; /* 오버레이를 위한 기준점 */
    }
    
    .bookmark-card img {
        position: static; 
        width: 100%;
        height: auto; /* 실제 비율 사용 */
        display: block;
        /* 기본: 이미지가 잘리지 않고 전체가 보이도록 contain 설정 */
        object-fit: contain; 
    }

    .bookmark-card .img-fit-cover {
        /* 비디오 썸네일용: 영역을 꽉 채우도록 cover 설정 */
        object-fit: cover; 
        height: 100%; /* content의 높이를 꽉 채우도록 설정 */
    }
    
    /* 아이콘/텍스트 오버레이 */
    .bookmark-card .icon-overlay {
        position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0, 0, 0, 0.6);
        display: flex; justify-content: center; align-items: center;
        color: white; font-size: 3rem;
    }
    /* 링크 북마크의 제목 표시 */
    .bookmark-card .link-title-overlay {
        position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        color: white; padding: 10px;
        text-align: center;
    }
    .bookmark-card .link-title-text {
        font-size: 1rem;
        font-weight: 700;
        margin-bottom: 5px;
        word-break: break-all;
    }
    .bookmark-card .link-url-text {
        font-size: 0.75rem;
        opacity: 0.7;
        word-break: break-all;
    }
    
    /* 신규 Video title overlay (썸네일 없을 때) */
    .bookmark-card .video-title-overlay {
        position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(80, 0, 0, 0.7); /* Reddish background for video emphasis */
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        color: white; padding: 10px;
        text-align: center;
    }
    .bookmark-card .video-title-text {
        font-size: 1rem;
        font-weight: 700;
        margin-bottom: 5px;
        word-break: break-all;
    }
    .bookmark-card .video-url-text {
        font-size: 0.75rem;
        opacity: 0.7;
        word-break: break-all;
    }
    
    /* 인스타그램 스타일 (이제 직접 임베드 코드를 사용하므로 이 스타일은 사용하지 않음) */
    
    /* 인스타그램 임베드 짤림 방지: 임베드 콘텐츠가 부모 카드 너비를 넘지 않도록 설정 */
    .bookmark-card .content > div[style*="max-width:540px"] {
        max-width: 100% !important; 
        width: 100% !important;
        box-sizing: border-box; /* 패딩/보더 포함 너비 계산 */
    }

    /* 사이트별 구분 헤더 스타일 */
    .domain-header {
        column-span: all; /* Masonry 레이아웃에서 전체 너비를 차지 */
        width: 100%;
        margin: 20px 0 10px;
        padding: 8px 0;
        color: #fff;
        font-size: 1.25rem;
        font-weight: 700;
        border-bottom: 2px solid #555;
        text-align: left;
    }

    @media (max-width:768px){
      body{padding:12px;gap:0}.section-card{padding:12px;border-radius:0}
      .notepad-tabs{gap:.5rem}.notepad-tab{padding:6px 12px;font-size:.8rem}
      .calendar-day{min-height:120px;padding:1.5rem .2rem .2rem;gap:1px}.day-number{font-size:.75rem;top:.5rem;left:.5rem}
      .task-item{font-size:.85rem;padding:2px 4px;margin-top:2px}
      .calendar-grid,.calendar-header{gap:0}.add-task-btn{width:100%;font-size:.9rem}
      .modal-content{padding:16px;width:95%}
      .domain-header { font-size: 1rem; }
    }
    .calendar-grid{grid-gap:4px}
    @media (max-width:768px){.calendar-grid{grid-gap:0}}

    /* 이미지 모달 스타일 */
    #imageModal.modal {
        background: rgba(0, 0, 0, 0.7);
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 9999;
    }
    #imageModal .modal-content {
        background-color: transparent;
        padding: 0;
        box-shadow: none;
        /* Set max dimensions based on viewport to prioritize height */
        max-width: 90vw; /* 90% viewport width */
        max-height: 90vh; /* 90% viewport height (세로에 맞춤) */
        width: auto; 
        height: auto; 
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer; /* 모달 내용을 클릭해서 닫기 위해 커서 추가 */
    }
    #modalImage {
        /* Fill the constrained container while maintaining aspect ratio */
        width: auto; 
        height: auto; 
        max-width: 100%; /* 모달 콘텐츠 크기 내에서 최대화 */
        max-height: 100%; /* 모달 콘텐츠 크기 내에서 최대화 */
        object-fit: contain; /* Crucial: Ensures the whole image is visible within 90vw/90vh without being cut off */
    }
    
    /* 북마크 제목 수정 모달 스타일 */
</style>
</head>
<body class="text-white">
  <div id="authBar" class="w-full max-w-2xl mx-auto flex items-center justify-end gap-2 mb-4">
    <span id="userInfo" class="text-sm opacity-80"></span>
    <button id="signInBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded">Google 로그인</button>
    <button id="signOutBtn" class="bg-gray-600 hover:bg-gray-700 text-white px-3 py-1 rounded hidden">로그아웃</button>
  </div>

  <div id="main-tabs" class="notepad-tabs mx-auto">
    <button class="notepad-tab active" data-tab="calendar">달력</button>
    <button class="notepad-tab" data-tab="notes">메모</button>
    <button class="notepad-tab" data-tab="bookmarks">북마크</button>
  </div>

  <div id="calendar-section" class="section-card tab-content active">
    <div class="flex justify-between items-center mb-4">
      <button id="prevMonthBtn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">&lt; 이전 달</button>
      <h2 id="currentMonthYear" class="text-lg font-bold"></h2>
      <button id="nextMonthBtn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">다음 달 &gt;</button>
    </div>
    <div class="calendar-header mb-2">
      <div class="day-label">월</div><div class="day-label">화</div><div class="day-label">수</div>
      <div class="day-label">목</div><div class="day-label">금</div><div class="day-label">토</div><div class="day-label">일</div>
    </div>
    <div id="calendarGrid" class="calendar-grid"></div>

    <!-- (달력 아래 리스트) : 문구/추가버튼 제거, 항목만 표시 -->
    <div id="agendaPanel" class="mt-6 text-left" style="background:#1f1f1f;border-radius:12px;padding:14px;box-shadow:inset 0 0 10px rgba(0,0,0,.25)">
      <div id="agendaList" class="space-y-2"></div>
    </div>
  </div>

  <div id="notes-section" class="section-card tab-content">
    <div class="flex items-center justify-between mb-2" id="notesHeaderRow">
      <div id="notesTabsContainer" class="notepad-tabs flex flex-wrap gap-2"></div>
      <div class="flex items-center gap-2">
        <button id="addNotesTabBtn" class="icon-btn" title="새 탭">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M12 5v14"/><path d="M5 12h14"/>
          </svg>
        </button>
        <button id="toggleNotesEditBtn" class="icon-btn" title="탭 편집">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M12 20h9"/><path d="M16.5 3.5a2.1 2.1 0 0 1 3 3L7 19l-4 1 1-4Z"/>
          </svg>
        </button>
      </div>
    </div>
    <textarea id="notesArea" class="w-full notes-area p-4 bg-black text-white border border-gray-700 focus:outline-none focus:ring-1 focus:ring-gray-500 rounded-lg"></textarea>
  </div>

  <div id="bookmarks-section" class="section-card tab-content text-left">
    <section id="drag-area" class="drag-area rounded-lg p-6 flex items-center justify-center text-center text-[#999] font-medium cursor-pointer" title="붙여넣기(Ctrl/Cmd+V)">
      <div class="text-4xl font-bold select-none">+</div>
    </section>
    <section id="image-grid"></section>
  </div>

  <div id="taskModal" class="modal">
    <div class="modal-content">
      <h2 id="modalTitle" class="text-2xl font-bold mb-4">새 작업</h2>
      <label class="block mb-2">제목:</label>
      <input type="text" id="taskTitle" class="w-full p-2 rounded-lg bg-gray-800 border border-gray-700 mb-4">
      <label class="block mb-2">설명:</label>
      <textarea id="taskDescription" class="w-full p-2 rounded-lg bg-gray-800 border border-gray-700 mb-4 h-24"></textarea>
      <label class="block mb-2">날짜:</label>
      <input type="date" id="taskDate" class="w-full p-2 rounded-lg bg-gray-800 border border-gray-700 mb-4">

      <label class="block mb-2">분류:</label>
      <select id="taskCategory" class="w-full p-2 rounded-lg bg-gray-800 border border-gray-700 mb-4">
        <option value="">(기본)</option>
        <option value="important">중요한일 (빨강)</option>
        <option value="family">가족행사 (파랑)</option>
        <option value="special">특별한날 (초록)</option>
      </select>

      <label class="flex items-center gap-2 mb-4 text-sm opacity-90" style="user-select:none;">
        <input type="checkbox" id="todoOnly" />
        달력에는 표시하지 않고 <b>할 일</b>로만 추가
      </label>
      <div class="flex justify-end gap-2">
        <button id="saveTaskBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">저장</button>
        <button id="cancelBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">취소</button>
        <button id="deleteTaskBtn" class="bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-4 rounded-lg hidden">삭제</button>
      </div>
    </div>
  </div>

  <div id="imageModal" class="modal">
    <div class="modal-content relative">
      <button id="closeImageModalBtn" class="absolute top-2 right-2 text-white bg-black bg-opacity-50 rounded-full p-1 z-50">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
      </button>
      <img id="modalImage" src="" alt="확대 이미지" />
      <button id="goToPageBtn" class="absolute bottom-4 left-1/2 -translate-x-1/2 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg z-50">원본 페이지로 이동</button>
    </div>
  </div>
  </div>
      <div class="flex justify-end gap-2 mt-4">
      </div>
    </div>
  </div>


  <div id="alert-modal" class="fixed inset-0 bg-[#1a1a1a] bg-opacity-50 flex items-center justify-center hidden z-50">
    <div class="bg-[#242424] rounded-lg p-6 shadow-xl max-w-sm mx-auto">
      <p id="modal-message" class="text-white text-lg text-center font-medium"></p>
      <div class="mt-4 flex justify-center">
        <button id="modal-close-btn" class="px-4 py-2 bg-[#424242] text-white rounded-md hover:bg-[#525252]">확인</button>
      </div>
    </div>
  </div>

  <div id="loading-overlay" class="fixed inset-0 bg-black bg-opacity-70 z-[1001] flex items-center justify-center hidden">
    <div class="flex flex-col items-center">
      <div class="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-white"></div>
      <p class="text-white mt-4 text-lg">데이터를 불러오는 중...</p>
    </div>
  </div>

<script>
    // (이 아래 UI 스크립트 내용은 변경 사항 없음)
    
    // 전역 상태
    window.customTasks = window.customTasks || [];
    window.taskStatus = window.taskStatus || {};
    window.__notesTabs = window.__notesTabs || {};
    window.imageBookmarks = window.imageBookmarks || []; // 북마크는 이미지와 , 일반 링크 모두 포함
    window.currentTask = null;
// 현재 편집 중인 북마크 항목
    let currentDate = new Date();
    window.isAuthReady = false;
    // 북마크는 최신순 고정(정렬 UI 제거)
    // 북마크 정렬: 최신순 고정
    // DOM 요소
    const tabButtons = document.querySelectorAll('#main-tabs .notepad-tab');
    const tabContents = document.querySelectorAll('.tab-content');
    // 메모 탭 UI는 notes.js가 관리 (여기서는 관여하지 않음)
    const notesArea = document.getElementById('notesArea');
    const dragArea = document.getElementById('drag-area');
    const imageGrid = document.getElementById('image-grid');
    const imageModal = document.getElementById('imageModal');
    const modalImage = document.getElementById('modalImage');
    const closeImageModalBtn = document.getElementById('closeImageModalBtn');
    const goToPageBtn = document.getElementById('goToPageBtn');

    // 유틸리티 함수
    const showFeedbackMessage = (message) => {
      const el = document.createElement('div');
      el.textContent = message;
      el.style.cssText="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,.8);color:#fff;padding:16px 20px;border-radius:10px;z-index:2000;max-width:90%";
      document.body.appendChild(el); setTimeout(()=>el.remove(),2000);
    };
    const showAlert = (msg) => { document.getElementById('modal-message').textContent = msg; document.getElementById('alert-modal').classList.remove('hidden'); };
    const hideAlert = () => { document.getElementById('alert-modal').classList.add('hidden'); };
    document.getElementById('modal-close-btn').addEventListener('click', hideAlert);

    const openImageModal = (imageUrl, pageUrl) => {
      modalImage.src = imageUrl;
      if (pageUrl){ goToPageBtn.style.display='block'; goToPageBtn.onclick=()=>window.open(pageUrl,'_blank'); }
      else goToPageBtn.style.display='none';
      imageModal.style.display='flex';
    };
    const closeImageModal = () => { imageModal.style.display = 'none'; };

    function showTab(tabId){
      tabContents.forEach(c=>c.classList.remove('active'));
      tabButtons.forEach(b=>b.classList.remove('active'));
      document.getElementById(`${tabId}-section`).classList.add('active');
      const btn=document.querySelector(`#main-tabs .notepad-tab[data-tab="${tabId}"]`); if(btn) btn.classList.add('active');
    }
    showTab('calendar');
    tabButtons.forEach(b=>b.addEventListener('click',()=>showTab(b.dataset.tab)));
    // (주의) 과거 메모 탭 선택 로직은 제거됨. notes.js가 담당.

    // 시간/날짜 관련 유틸리티
    const TZ='Asia/Seoul';
    function ymdKST(date){ return new Intl.DateTimeFormat('en-CA',{timeZone:TZ,year:'numeric',month:'2-digit',day:'2-digit'}).format(date); }
    function toKST(date){ return new Date(date.toLocaleString('en-US',{timeZone:TZ})); }
    function countWeekdaysBetweenKST(a,b){ let c=0,start=toKST(new Date(Math.min(a,b))),end=toKST(new Date(Math.max(a,b))),cur=new Date(start); while(cur<=end){ const d=cur.getDay(); if(d>=1&&d<=5)c++; cur.setDate(cur.getDate()+1);} return c;}
    // ===== Episode calculator: episodes increase on weekdays (Mon~Fri) =====
    // 기준: 2026-02-02(월) = 2123화 (주말은 회차 진행 없음)
    function isEpisodeDay(dateObj){
      const dow = dateObj.getDay(); // 0=Sun ... 6=Sat
      return dow >= 1 && dow <= 5;  // Mon~Fri
    }

    function countEpisodeDaysExclusiveStartInclusiveEnd(startDateObj, endDateObj){
      // counts eligible days in (start, end] assuming start < end
      let count = 0;
      const cur = new Date(startDateObj.getFullYear(), startDateObj.getMonth(), startDateObj.getDate());
      const end = new Date(endDateObj.getFullYear(), endDateObj.getMonth(), endDateObj.getDate());
      cur.setDate(cur.getDate() + 1);
      while(cur <= end){
        if(isEpisodeDay(cur)) count++;
        cur.setDate(cur.getDate() + 1);
      }
      return count;
    }

    function episodeNumberForDate(targetDateObj){
      const baseDate = new Date(2026, 1, 2); // 2026-02-02 (Mon)
      const baseEpisode = 2123;

      const t = new Date(targetDateObj.getFullYear(), targetDateObj.getMonth(), targetDateObj.getDate());

      if(t.getTime() === baseDate.getTime()) return baseEpisode;

      if(t > baseDate){
        const n = countEpisodeDaysExclusiveStartInclusiveEnd(baseDate, t);
        return baseEpisode + n;
      } else {
        const n = countEpisodeDaysExclusiveStartInclusiveEnd(t, baseDate);
        return baseEpisode - n;
      }
    }


    // const fixedSchedules=[{title:'쇼츠',daysOfWeek:[1,3,5],colorClass:'recurring-shorts'},{title:'웹툰',daysOfWeek:[2,4,6],colorClass:'recurring-instatoon'}];

    // 모달 관련 DOM
    const taskModal=document.getElementById('taskModal');
    const cancelBtn=document.getElementById('cancelBtn');
    const saveTaskBtn=document.getElementById('saveTaskBtn');
    const deleteTaskBtn=document.getElementById('deleteTaskBtn');
    const taskTitleInput=document.getElementById('taskTitle');
    const taskDescriptionInput=document.getElementById('taskDescription');
    const taskDateInput=document.getElementById('taskDate');
    const taskCategorySelect=document.getElementById('taskCategory');
    const todoOnlyCheckbox=document.getElementById('todoOnly');

    // 달력 아래 리스트
    const agendaListEl=document.getElementById('agendaList');

    // 이벤트 리스너 부착
    const attachEventListeners=()=>{
      const prevMonthBtn=document.getElementById('prevMonthBtn');
      const nextMonthBtn=document.getElementById('nextMonthBtn');
      prevMonthBtn?.addEventListener('click',()=>{ currentDate.setMonth(currentDate.getMonth()-1); renderCalendar(); });
      nextMonthBtn?.addEventListener('click',()=>{ currentDate.setMonth(currentDate.getMonth()+1); renderCalendar(); });
      // 상단/하단의 "+추가" 버튼은 제거됨. (날짜 클릭/설정 버튼으로 추가/편집)

      // "달력에는 표시하지 않고 할 일로만" 토글
      todoOnlyCheckbox?.addEventListener('change',()=>{
        const on = !!todoOnlyCheckbox.checked;
        if(taskDateInput){
          taskDateInput.disabled = on;
          if(on) taskDateInput.value = '';
        }
      });
      if(notesArea){
        notesArea.addEventListener('input',()=>window.cloudSaveNotesDebounced&&window.cloudSaveNotesDebounced());
        notesArea.addEventListener('blur',()=>window.cloudSaveNotes&&window.cloudSaveNotes());
      }
      cancelBtn.addEventListener('click',closeModal);
      saveTaskBtn.addEventListener('click',saveTask);
      // window.deleteTask는 Firebase 스크립트에서 정의됨
      deleteTaskBtn.addEventListener('click',()=>window.deleteTask&&window.deleteTask());
      taskModal.addEventListener('click',(e)=>{ if(e.target===taskModal) closeModal(); });

      closeImageModalBtn.addEventListener('click', closeImageModal);
      // 이미지 모달 배경 클릭 시 닫기
      imageModal.addEventListener('click',(e)=>{ if(e.target===imageModal) closeImageModal(); }); 
      // 추가: 모달 내용 (이미지 포함) 클릭 시 닫기
      document.querySelector('#imageModal .modal-content').addEventListener('click', (e) => {
          // X 버튼, 원본 페이지 이동 버튼을 제외하고 닫기
          if (!e.target.closest('#closeImageModalBtn') && !e.target.closest('#goToPageBtn')) {
              closeImageModal();
          }
      });
      
      // 정렬 UI는 제거됨 (최신순 고정)
    };

    // 달력 렌더링
    const renderCalendar=()=>{
      const year=currentDate.getFullYear(), month=currentDate.getMonth();
      const currentMonthYear=document.getElementById('currentMonthYear');
      const calendarGrid=document.getElementById('calendarGrid'); if(!currentMonthYear||!calendarGrid) return;
      currentMonthYear.textContent=`${year}년 ${month+1}월`; calendarGrid.innerHTML='';
      const firstDay=new Date(year,month,1).getDay(); const daysInMonth=new Date(year,month+1,0).getDate();
      // Week starts on Monday (월~일). Convert JS getDay() (Sun=0..Sat=6) to Monday-first index.
      const leadingBlanks=(firstDay+6)%7;
      for(let i=0;i<leadingBlanks;i++){ const empty=document.createElement('div'); empty.className='calendar-day'; calendarGrid.appendChild(empty); }
      for(let day=1;day<=daysInMonth;day++){
        const dayDiv=document.createElement('div'); dayDiv.classList.add('calendar-day','relative');
        const thisDate=new Date(year,month,day); const fullDate=ymdKST(thisDate); const dayOfWeek=thisDate.getDay();
        const today=new Date(); if(ymdKST(thisDate)===ymdKST(today)) dayDiv.classList.add('today');
        const dayNumberSpan=document.createElement('span'); dayNumberSpan.classList.add('day-number'); dayNumberSpan.textContent=day; dayDiv.appendChild(dayNumberSpan);

        // 날짜 숫자 아래 구분선
        const divider = document.createElement('div');
        divider.className = 'day-divider';
        dayDiv.appendChild(divider);

        // 1) 매일 쇼츠/웹툰 체크 버튼 그룹 (항상 최상단)
        const checkGroup = document.createElement('div');
        checkGroup.className = 'daily-check-group';

        // 쇼츠 버튼
        const shortsBtn = document.createElement('div');
        shortsBtn.className = 'daily-check-btn shorts';
        shortsBtn.textContent = '쇼츠';
        const shortsKey = `${fullDate}_daily_shorts`;
        if ((window.taskStatus || {})[shortsKey]) shortsBtn.classList.add('active');
        shortsBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            if (!window.ensureLogin || !window.ensureLogin()) return;
            window.taskStatus = window.taskStatus || {};
            window.taskStatus[shortsKey] = !window.taskStatus[shortsKey];
            await window.cloudSaveStateOnly();
            renderCalendar();
        });

        // 웹툰 버튼
        const webtoonBtn = document.createElement('div');
        webtoonBtn.className = 'daily-check-btn webtoon';
        webtoonBtn.textContent = '웹툰';
        const webtoonKey = `${fullDate}_daily_webtoon`;
        if ((window.taskStatus || {})[webtoonKey]) webtoonBtn.classList.add('active');
        webtoonBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            if (!window.ensureLogin || !window.ensureLogin()) return;
            window.taskStatus = window.taskStatus || {};
            window.taskStatus[webtoonKey] = !window.taskStatus[webtoonKey];
            await window.cloudSaveStateOnly();
            renderCalendar();
        });

        checkGroup.appendChild(shortsBtn);
        checkGroup.appendChild(webtoonBtn);
        dayDiv.appendChild(checkGroup);

        // 2) 에피소드 정보 (월~금만 표시) - 쇼츠/웹툰 아래
        //    주말(토/일)은 회차 진행이 없으므로 표시하지 않음.
        if(isEpisodeDay(thisDate)){
          const episodeNumber = episodeNumberForDate(thisDate);
          const epItem=document.createElement('div'); 
          epItem.classList.add('task-item','episode-task'); 
          epItem.textContent=`${episodeNumber}화`;
          const key=`${fullDate}_바퀴멘터리 ${episodeNumber}화`; 
          if((window.taskStatus||{})[key]) epItem.classList.add('complete');
          epItem.addEventListener('click',async(e)=>{ 
            e.stopPropagation(); 
            if(!window.ensureLogin||!window.ensureLogin()) return; 
            window.taskStatus=window.taskStatus||{}; 
            window.taskStatus[key]=!window.taskStatus[key]; 
            await window.cloudSaveStateOnly(); 
            renderCalendar();
          });
          dayDiv.appendChild(epItem);
        }


        // 3) 사용자 커스텀 태스크 (개인작업) - 에피소드 아래
        (window.customTasks||[]).filter(t=>t.date===fullDate).forEach(task=>{
          const el=document.createElement('div'); 
          el.classList.add('task-item','custom-task');
          if(task.category==='important') el.classList.add('custom-important');
          if(task.category==='family') el.classList.add('custom-family');
          if(task.category==='special') el.classList.add('custom-special');
          el.textContent=task.title;
          if(task.complete) el.classList.add('complete');
          el.addEventListener('click',async(e)=>{ if(e.detail===1){ if(!window.ensureLogin||!window.ensureLogin()) return; task.complete=!task.complete; await window.cloudSaveAll(); renderCalendar(); } else if(e.detail===2){ openModal(task); }});
          dayDiv.appendChild(el);
        });

        dayDiv.addEventListener('click',(e)=>{ if(e.target.classList.contains('calendar-day')||e.target.classList.contains('day-number')) openModal({date:fullDate});});
        calendarGrid.appendChild(dayDiv);
      }

      // 달력 아래 리스트도 함께 갱신
      renderAgendaList();
    };

    // 달력 아래 리스트 (문구/추가버튼/체크박스 제거)
    const renderAgendaList = ()=>{
      if(!agendaListEl) return;
      const tasks = (window.customTasks||[]).slice();
      const order = { important: 1, family: 2, special: 3 };
      const dotColor = (cat)=>{
        if(cat==='important') return '#dc2626';
        if(cat==='family') return '#2563eb';
        if(cat==='special') return '#16a34a';
        return '#9ca3af';
      };

      // D-day 계산 (KST 자정 기준)
      const toKSTMidnight = (d)=>{
        const k = toKST(d);
        return new Date(k.getFullYear(), k.getMonth(), k.getDate());
      };
      const parseYMD = (s)=>{
        const [y,m,dd] = String(s).split('-').map(Number);
        return new Date(y, (m||1)-1, dd||1);
      };
      const diffDaysFromToday = (ymd)=>{
        const today = toKSTMidnight(new Date());
        const target = toKSTMidnight(parseYMD(ymd));
        return Math.round((target - today) / (1000*60*60*24));
      };
      const formatDday = (ymd)=>{
        const diff = diffDaysFromToday(ymd);
        if(diff === 0) return 'D-day';
        if(diff > 0) return `D-${diff}`;
        return null; // 지난 일정은 표시하지 않음
      };

      const dated = tasks
        .filter(t=>!!t.date && ['important','family','special'].includes(t.category) && formatDday(t.date))
        .sort((a,b)=>{
          const ca = !!a.complete, cb = !!b.complete;
          if(ca!==cb) return ca ? 1 : -1; // 완료는 아래로
          const da = String(a.date); const db = String(b.date);
          if(da!==db) return da.localeCompare(db);
          return (order[a.category]||99) - (order[b.category]||99);
        });

      const undated = tasks
        .filter(t=>!t.date || String(t.date).trim()==='')
        .sort((a,b)=>{
          // 미완료 우선, 그 다음 최신순
          const ca = !!a.complete, cb = !!b.complete;
          if(ca!==cb) return ca ? 1 : -1;
          return Number(b.id||0) - Number(a.id||0);
        });

      const makeRow = (t, {showDate})=>{
        const row = document.createElement('div');
        row.className = 'agenda-item';

        const dot = document.createElement('div');
        dot.className = 'agenda-dot';
        dot.style.background = dotColor(t.category);

        const date = document.createElement('div');
        date.className = 'agenda-date';
        date.textContent = showDate ? (formatDday(t.date) || '') : '';

        const text = document.createElement('div');
        text.className = 'agenda-text';
        text.textContent = t.title;
        if(t.complete){
          row.classList.add('complete');
          // 완료 표시(원래처럼): 회색 + 취소선
          text.style.textDecoration='line-through';
          text.style.opacity='.9';
          text.style.color = '#7a7a7a';
        }

        const actions = document.createElement('div');
        actions.className = 'agenda-actions';

        // 설정(편집) 버튼만 유지
        const settingsBtn = document.createElement('button');
        settingsBtn.className = 'agenda-settings-btn';
        settingsBtn.type = 'button';
        settingsBtn.setAttribute('title','설정');
        settingsBtn.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" style="width:18px;height:18px;opacity:.9">
            <path d="M12 20a1 1 0 0 1-1-1v-1.1a7.8 7.8 0 0 1-1.9-.8l-.8.8a1 1 0 0 1-1.4 0l-1.4-1.4a1 1 0 0 1 0-1.4l.8-.8a7.8 7.8 0 0 1-.8-1.9H4a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h1.1a7.8 7.8 0 0 1 .8-1.9l-.8-.8a1 1 0 0 1 0-1.4l1.4-1.4a1 1 0 0 1 1.4 0l.8.8a7.8 7.8 0 0 1 1.9-.8V5a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v1.1a7.8 7.8 0 0 1 1.9.8l.8-.8a1 1 0 0 1 1.4 0l1.4 1.4a1 1 0 0 1 0 1.4l-.8.8a7.8 7.8 0 0 1 .8 1.9H20a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-1.1a7.8 7.8 0 0 1-.8 1.9l.8.8a1 1 0 0 1 0 1.4l-1.4 1.4a1 1 0 0 1-1.4 0l-.8-.8a7.8 7.8 0 0 1-1.9.8V19a1 1 0 0 1-1 1z"/>
            <circle cx="12" cy="12" r="3"/>
          </svg>`;
        settingsBtn.addEventListener('click',(e)=>{ e.stopPropagation(); openModal(t); });
        actions.appendChild(settingsBtn);

        row.appendChild(dot);
        row.appendChild(date);
        row.appendChild(text);
        row.appendChild(actions);

        // 항목 클릭: 완료 토글(체크박스 대신)
        row.addEventListener('click', async ()=>{
          if(!window.ensureLogin||!window.ensureLogin()) return;
          t.complete = !t.complete;

          // 즉시 UI 반영: 회색 + 취소선 (원래처럼)
          row.classList.toggle('complete', !!t.complete);
          if(t.complete){
            text.style.textDecoration='line-through';
            text.style.opacity='.9';
            text.style.color = '#7a7a7a';
          } else {
            text.style.textDecoration='';
            text.style.opacity='';
            text.style.color = '';
          }

          // 완료 항목은 아래로 이동
          if(row.parentElement){
            const parent = row.parentElement;
            if(t.complete) parent.appendChild(row);
            else parent.prepend(row);
          }

          await window.cloudSaveAll();
          renderCalendar();
        });
        return row;
      };

      agendaListEl.innerHTML = '';

      // 1) 날짜 없는 항목을 위로
      undated.forEach(t=>agendaListEl.appendChild(makeRow(t,{showDate:false})));
      // 2) 날짜 있는 일정은 아래로
      dated.forEach(t=>agendaListEl.appendChild(makeRow(t,{showDate:true})));
    };

        

// 북마크 렌더링 (이미지 및  포함)
        // 북마크 렌더링 (이미지 / 링크)
    const renderImageBookmarks = () => {
      if (!imageGrid) return;
      imageGrid.innerHTML = '';

      const items = [...(window.imageBookmarks || [])];
      // 최신순 고정
      items.sort((a, b) => (b.timestamp?.toMillis?.() || 0) - (a.timestamp?.toMillis?.() || 0));

      items.forEach((d) => {
        const isImage = d.type === 'firebase_storage' || d.type === 'remote';
        const isLink = d.type === 'link';

        const card = document.createElement('div');
        card.className = 'bookmark-card';

        const safeDomain = (d.sourceDomain || (d.pageUrl ? extractDomain(d.pageUrl) : 'Bookmark'));
        const url = d.pageUrl || d.url || '';

        // 상단 액션
        const actions = document.createElement('div');
        actions.style.cssText = "display:flex;justify-content:flex-end;gap:8px;padding:8px 10px;";

        // 링크 열기 버튼(링크 타입일 때만)
        if (isLink && url) {
          const openBtn = document.createElement('button');
          openBtn.textContent = '열기';
          openBtn.className = 'px-3 py-1 rounded bg-gray-700 hover:bg-gray-600 text-white text-sm';
          openBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            window.open(url, '_blank', 'noopener,noreferrer');
          });
          actions.appendChild(openBtn);
        }

        // 삭제 버튼
        const delBtn = document.createElement('button');
        delBtn.textContent = '삭제';
        delBtn.className = 'px-3 py-1 rounded bg-gray-800 hover:bg-gray-700 text-white text-sm';
        delBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          if (window.deleteImage) await window.deleteImage(d.id);
        });
        actions.appendChild(delBtn);

        // 본문
        const body = document.createElement('div');
        body.className = 'content';

        if (isImage && d.url) {
          const img = document.createElement('img');
          img.src = d.url;
          img.alt = safeDomain;
          img.loading = 'lazy';
          img.style.cssText = "width:100%;height:220px;object-fit:cover;border-radius:10px;cursor:pointer;";
          img.addEventListener('click', () => {
            if (window.openImageModal) window.openImageModal(d.url, d.pageUrl || null);
          });
          body.appendChild(img);
        } else if (isLink && url) {
          const wrap = document.createElement('div');
          wrap.style.cssText = "padding:16px;display:flex;flex-direction:column;gap:6px;";
          const domainEl = document.createElement('div');
          domainEl.textContent = safeDomain;
          domainEl.style.cssText = "font-weight:700;color:#fff;";
          const urlEl = document.createElement('div');
          urlEl.textContent = url;
          urlEl.style.cssText = "color:#aaa;word-break:break-all;font-size:12px;";
          wrap.appendChild(domainEl);
          wrap.appendChild(urlEl);
          body.appendChild(wrap);
        } else {
          const empty = document.createElement('div');
          empty.style.cssText = "padding:16px;color:#aaa;";
          empty.textContent = safeDomain;
          body.appendChild(empty);
        }

        card.appendChild(actions);
        card.appendChild(body);
        imageGrid.appendChild(card);
      });
    };

    // 작업 모달
    const openModal=(task=null)=>{
      window.currentTask=task;
      if(task&&task.id){
        document.getElementById('modalTitle').textContent='작업 수정';
        taskTitleInput.value=task.title;
        taskDescriptionInput.value=task.description||'';
        taskDateInput.value=task.date||'';
        if(taskCategorySelect) taskCategorySelect.value = task.category || '';
        if(todoOnlyCheckbox) todoOnlyCheckbox.checked = !!task.todoOnly || !task.date;
        if(taskDateInput) taskDateInput.disabled = !!(todoOnlyCheckbox && todoOnlyCheckbox.checked);
        deleteTaskBtn.classList.remove('hidden');
      }
      else if(task&&('date' in task)){
        document.getElementById('modalTitle').textContent='새 작업';
        taskTitleInput.value='';
        taskDescriptionInput.value='';
        taskDateInput.value=task.date||'';
        if(taskCategorySelect) taskCategorySelect.value = task.category || '';
        if(todoOnlyCheckbox) todoOnlyCheckbox.checked = !!task.todoOnly || !task.date;
        if(taskDateInput) taskDateInput.disabled = !!(todoOnlyCheckbox && todoOnlyCheckbox.checked);
        deleteTaskBtn.classList.add('hidden');
      }
      else{
        document.getElementById('modalTitle').textContent='새 작업';
        taskTitleInput.value='';
        taskDescriptionInput.value='';
        taskDateInput.value='';
        if(taskCategorySelect) taskCategorySelect.value = '';
        if(todoOnlyCheckbox) todoOnlyCheckbox.checked = false;
        if(taskDateInput) taskDateInput.disabled = false;
        deleteTaskBtn.classList.add('hidden');
      }
      taskModal.style.display='flex';
    };
    const closeModal=()=>{ taskModal.style.display='none'; };

    const saveTask=async ()=>{
      if(!window.ensureLogin||!window.ensureLogin()) return;
      window.customTasks=window.customTasks||[]; window.taskStatus=window.taskStatus||{};
      const title=taskTitleInput.value.trim(); const description=taskDescriptionInput.value.trim(); const date=taskDateInput.value;
      const category = taskCategorySelect ? (taskCategorySelect.value || '') : '';
      const todoOnly = !!(todoOnlyCheckbox && todoOnlyCheckbox.checked);
      if(!title){ showFeedbackMessage('제목을 입력해주세요.'); return; }
      const finalDate = todoOnly ? '' : date;
      const data={ 
        id: window.currentTask&&window.currentTask.id ? window.currentTask.id : Date.now(),
        title, 
        description, 
        date: finalDate,
        category,
        todoOnly,
        complete: window.currentTask?.complete ?? false 
      };
      const idx=window.customTasks.findIndex(t=>t.id===data.id); if(idx>-1) window.customTasks[idx]=data; else window.customTasks.push(data);
      await window.cloudSaveAll(); closeModal(); renderCalendar();
    };
if(!imgItem) return;
        e.preventDefault();
        const blob = imgItem.getAsFile();
        if(!blob) return;
        const file = new File([blob], fileName, { type: blob.type || 'image/png' });
        try{
            showFeedbackMessage('미리보기 이미지 업로드 중...');
            showFeedbackMessage('미리보기 이미지가 저장되었습니다.');
        }catch(err){
            console.error(err);
            showAlert('미리보기 이미지 업로드 중 오류가 발생했습니다.');
        }
    });

    (function init(){ 
        attachEventListeners(); 
        renderCalendar(); 
    })();

    // main.js(모듈)에서도 호출할 수 있도록 노출
    window.renderCalendar = renderCalendar;

    // ===== D&D/붙여넣기/클릭-자동붙여넣기 =====
    function isImageUrl(u){
      try{ new URL(u); }catch{ return false; }
      return /\.(jpe?g|png|gif|webp|svg|avif)(\?|$)/i.test(u);
    }
    
    // 인스타그램 퍼가기 코드 확인 (blockquote 태그를 포함하는지 확인)
    
    // **신규: 도메인 추출 유틸리티**
    function extractDomain(url) {
        if (!url) return 'Unknown';
        try {
            const urlObj = new URL(url.includes('://') ? url : 'https://' + url);
            let domain = urlObj.hostname;
            if (domain.startsWith('www.')) domain = domain.substring(4);
            return domain;
        } catch {
            return 'Unknown';
        }
    }


    // URL 유효성 검사
    function isGenericUrl(u) {
        if (!u) return false;
        try {
            const urlObj = new URL(u);
            return (urlObj.protocol === 'http:' || urlObj.protocol === 'https:');
        } catch {
            return false;
        }

    }

    // 드래그앤드롭 핸들러
    dragArea.addEventListener('dragover',(e)=>{ e.preventDefault(); dragArea.classList.add('active'); });
    dragArea.addEventListener('dragleave',()=>{ dragArea.classList.remove('active'); });
    dragArea.addEventListener('drop',async(e)=>{
      e.preventDefault(); dragArea.classList.remove('active');
      const dt=e.dataTransfer;
      const html=dt.getData('text/html');
      const plainText = dt.getData('text/plain');

      let url=null, pageUrl=null;
      // 1. 드롭된 내용에서 이미지 URL 추출 시도
      if(html){
        const doc=new DOMParser().parseFromString(html,'text/html');
        const img=doc.querySelector('img');
        if(img?.src){ url=img.src; pageUrl=dt.getData('text/uri-list')||dt.getData('URL')||null; }
      }
      // 3. 드롭된 내용에서 일반 URL 추출 시도
      if(!url){ const u=dt.getData('text/uri-list')||dt.getData('URL')||plainText; if(u) { url=u; pageUrl=u; } }

      // 4. 북마크 처리 (URL인 경우)
      if(url){
          if(isImageUrl(url)){ 
              // 이미지 URL 북마크
              if(window.addRemoteImage){ await window.addRemoteImage(url,pageUrl); showFeedbackMessage('이미지 URL 북마크됨'); } 
              return; 
          } else if(isGenericUrl(url)) {
              // 일반 페이지 URL 북마크
              if(window.addGenericBookmark) { await window.addGenericBookmark(url); showFeedbackMessage('페이지 URL 북마크됨'); }
              return;
          }
      }

      // 5. 파일 드롭 처리 (캡쳐 이미지는 붙여넣기 안내)
      const files=[...(dt.files||[])].filter(f=>f.type.startsWith('image/'));
      if(files.length){ 
          // [수정] 파일 드롭 시 window.addImage 호출
          if(window.addImage){ await window.addImage(files[0], null); showFeedbackMessage('이미지 업로드됨'); return; }
      }

      showAlert('유효한 콘텐츠를 찾지 못했습니다.');
    });

    // 클릭: 클립보드 접근 및 자동 붙여넣기 시도
    dragArea.addEventListener('click', async ()=>{
      try{
        let processed = false;
        
        // 1. 클립보드 이미지 처리
        if(navigator.clipboard?.read){
          const items=await navigator.clipboard.read();
          for(const it of items){
            for(const type of it.types){
              if(type.startsWith('image/')){
                const blob=await it.getType(type);
                if(window.addImage){ await window.addImage(new File([blob],'clipboard-image',{type:blob.type}), null); showFeedbackMessage('클립보드 이미지 업로드됨'); processed=true; return; }
              }
            }
          }
        }
        
        // 2. 클립보드 텍스트 (URL/퍼가기 코드) 처리
        const t = await navigator.clipboard.readText();
        if(t){
            if(isImageUrl(t)){ 
                if(window.addRemoteImage){ await window.addRemoteImage(t,t); showFeedbackMessage('클립보드 이미지 URL 북마크됨'); processed=true; return; } 
            } else if(isGenericUrl(t)) {
                if(window.addGenericBookmark) { await window.addGenericBookmark(t); showFeedbackMessage('클립보드 페이지 URL 북마크됨'); processed=true; return; }
            }
        }
        
        if(!processed) showAlert('클립보드에서 유효한 콘텐츠를 읽지 못했습니다.');
      }catch(e){ console.error(e); showAlert('클립보드 권한을 허용하세요.'); }
    });

    // 붙여넣기 핸들러
    dragArea.addEventListener('paste', async (e)=>{
      e.preventDefault();
      const items=[...(e.clipboardData||e.originalEvent?.clipboardData)?.items||[]];
      let foundText = null;

      for(const item of items){
        // 1. 이미지 파일 처리
        if(item.kind==='file' && item.type.startsWith('image/')){
          const file=item.getAsFile(); 
          if(file && window.addImage){ await window.addImage(file,null); showFeedbackMessage('이미지 업로드됨'); return; }
        }
        // 2. 텍스트 처리
        if(item.kind==='string'){
          const txt=await new Promise(r=>item.getAsString(r));
          if(txt){
             if(isImageUrl(txt)){ 
                if(window.addRemoteImage){ await window.addRemoteImage(txt,txt); showFeedbackMessage('URL 북마크됨'); return; } 
             } else if(isGenericUrl(txt)){
                 if(window.addGenericBookmark) { await window.addGenericBookmark(txt); showFeedbackMessage('페이지 URL 북마크됨'); return; }
             }
             foundText = txt;
          }
        }
      }
      
      // Fallback: plain text
      if (!foundText) {
          const plain=e.clipboardData?.getData('text/plain');
          if(plain){
             if(isImageUrl(plain)){ 
                if(window.addRemoteImage){ await window.addRemoteImage(plain,plain); showFeedbackMessage('URL 북마크됨'); return; } 
             } else if(isGenericUrl(plain)){
                if(window.addGenericBookmark) { await window.addGenericBookmark(plain); showFeedbackMessage('페이지 URL 북마크됨'); return; }
             }
          }
      }
      
      showAlert('붙여넣기한 항목에 유효한 이미지 또는 URL이 없습니다.');
    });

</script>


<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, deleteDoc, collection, onSnapshot, addDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    

// ===== Inlined modules: calendar.js / notes.js / bookmarks.js =====
// calendar.js
// NOTE: Calendar UI is rendered by ui.js.
// This module is kept to avoid breaking existing imports in main.js,
// but it intentionally does not attach listeners or override global render functions.
function initCalendar() {
  // no-op (handled in ui.js)
}


function initNotes(){
  const notesArea = document.getElementById('notesArea');
  const tabsContainer = document.getElementById('notesTabsContainer');
  const addTabBtn = document.getElementById('addNotesTabBtn');
  const toggleEditBtn = document.getElementById('toggleNotesEditBtn');

  if(!tabsContainer || !notesArea) return;

  // Local UI state
  let editMode = false;

  // Helpers
  const genId = ()=> 'tab_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2,7);

  const getState = ()=>({
    tabs: window.__notesTabList || [{ id:'memo', name:'메모', order:0 }],
    notes: window.__notesTabs || {},
    activeId: window.__notesActiveTabId || 'memo'
  });

  const setActive = async (tabId)=>{
    // 1) 현재 탭 내용을 먼저 로컬/클라우드에 확정 저장 (탭 전환 중 유실 방지)
    const prevId = window.__notesActiveTabId || 'memo';
    try{
      if(notesArea){
        window.__notesTabs = window.__notesTabs || {};
        window.__notesTabs[prevId] = notesArea.value ?? '';
        // 디바운스가 남아있더라도 이전 탭은 즉시 저장(최소 1회 보장)
        if(window.cloudSaveNotesFor){
          await window.cloudSaveNotesFor(prevId, window.__notesTabs[prevId]);
        }else if(window.cloudSaveNotes){
          await window.cloudSaveNotes();
        }
      }
    }catch(_){}

    // 2) active tab 변경 + 서버에 activeId 기록
    window.__notesActiveTabId = tabId;
    try{
      window.cloudSetActiveNotesTab && await window.cloudSetActiveNotesTab(tabId);
    }catch(_){}

    // 3) UI 갱신
    render();
    const { notes } = getState();
    notesArea.value = notes[tabId] || '';
  };

  const render = ()=>{
    const { tabs, activeId, notes } = getState();
    // normalize tabs ordering
    const sorted = [...tabs].sort((a,b)=>(a.order??0)-(b.order??0));
    tabsContainer.innerHTML = '';

    sorted.forEach((t)=>{
      const btn = document.createElement('button');
      btn.className = 'notes-tab' + (t.id===activeId ? ' active' : '');
      btn.dataset.tabId = t.id;
      btn.draggable = editMode;
      btn.innerHTML = `
        <span class="tab-label">${escapeHtml(t.name || '')}</span>
        ${editMode ? `<span class="tab-del" title="삭제">×</span>` : ``}
      `;
      tabsContainer.appendChild(btn);
    });

    // Ensure textarea shows active note
    const activeExists = sorted.some(t=>t.id===activeId);
    const useId = activeExists ? activeId : (sorted[0]?.id || 'memo');
    if(useId !== activeId){
      window.__notesActiveTabId = useId;
    }
    notesArea.value = notes[useId] || '';

    // Toggle button icon
    if(toggleEditBtn){
      toggleEditBtn.innerHTML = editMode
        ? `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M20 6 9 17l-5-5"/></svg>`
        : `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M12 20h9"/><path d="M16.5 3.5a2.1 2.1 0 0 1 3 3L7 19l-4 1 1-4Z"/></svg>`;
    }
  };

  const escapeHtml = (s)=> String(s)
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'","&#039;");

  const promptName = (title, current='')=>{
    const name = window.prompt(title, current);
    if(name===null) return null;
    const trimmed = name.trim();
    if(!trimmed) return null;
    return trimmed.slice(0, 20);
  };

  // Events: select / rename / delete
  tabsContainer.addEventListener('click', async (e)=>{
    const tabBtn = e.target.closest('.notes-tab');
    if(!tabBtn) return;
    const tabId = tabBtn.dataset.tabId;

    // delete in edit mode
    if(editMode && e.target.classList.contains('tab-del')){
      if(!confirm('이 탭과 탭 안의 메모를 삭제할까요?')) return;
      window.cloudDeleteNotesTab && await window.cloudDeleteNotesTab(tabId);
      return;
    }

    // select
    await setActive(tabId);
  });

  tabsContainer.addEventListener('dblclick', async (e)=>{
    const tabBtn = e.target.closest('.notes-tab');
    if(!tabBtn) return;
    const tabId = tabBtn.dataset.tabId;
    const { tabs } = getState();
    const cur = tabs.find(t=>t.id===tabId);
    const newName = promptName('탭 이름 변경', cur?.name || '');
    if(!newName) return;
    window.cloudRenameNotesTab && await window.cloudRenameNotesTab(tabId, newName);
  });

  // Drag reorder (edit mode only) - live reflow + smooth-ish
  let dragFromId = null;
  let draggingEl = null;
  let placeholderEl = null;

  function ensurePlaceholder(width){
    if(placeholderEl) return;
    placeholderEl = document.createElement('div');
    placeholderEl.className = 'notes-tab placeholder';
    placeholderEl.style.width = (width || 80) + 'px';
    placeholderEl.style.height = '32px';
    placeholderEl.style.borderRadius = '10px 10px 0 0';
    placeholderEl.style.border = '1px dashed rgba(255,255,255,.25)';
    placeholderEl.style.background = 'transparent';
  }

  function getDragAfterElement(container, x){
    const els = [...container.querySelectorAll('.notes-tab:not(.dragging):not(.placeholder)')];
    let closest = { offset: Number.NEGATIVE_INFINITY, element: null };
    for(const child of els){
      const box = child.getBoundingClientRect();
      const offset = x - (box.left + box.width/2);
      if(offset < 0 && offset > closest.offset){
        closest = { offset, element: child };
      }
    }
    return closest.element;
  }

  tabsContainer.addEventListener('dragstart', (e)=>{
    if(!editMode) return;
    const tabBtn = e.target.closest('.notes-tab');
    if(!tabBtn) return;
    dragFromId = tabBtn.dataset.tabId;
    draggingEl = tabBtn;
    draggingEl.classList.add('dragging');

    // placeholder for live layout
    const w = tabBtn.getBoundingClientRect().width;
    ensurePlaceholder(w);
    placeholderEl.style.width = w + 'px';
    tabBtn.after(placeholderEl);

    // Better drag image (avoid huge ghost)
    if(e.dataTransfer){
      e.dataTransfer.effectAllowed = 'move';
      try{
        const img = tabBtn.cloneNode(true);
        img.style.position = 'absolute';
        img.style.top = '-9999px';
        img.style.left = '-9999px';
        img.style.opacity = '0.9';
        document.body.appendChild(img);
        e.dataTransfer.setDragImage(img, 10, 10);
        setTimeout(()=>img.remove(), 0);
      }catch(_){}
    }
  });

  tabsContainer.addEventListener('dragover', (e)=>{
    if(!editMode || !draggingEl) return;
    e.preventDefault();
    const afterEl = getDragAfterElement(tabsContainer, e.clientX);
    if(!afterEl){
      tabsContainer.appendChild(placeholderEl);
    }else{
      tabsContainer.insertBefore(placeholderEl, afterEl);
    }
  });

  async function finalizeReorder(){
    if(!draggingEl || !placeholderEl) return;
    placeholderEl.replaceWith(draggingEl);
    draggingEl.classList.remove('dragging');

    // compute order from DOM
    const ids = [...tabsContainer.querySelectorAll('.notes-tab')].filter(el=>!el.classList.contains('placeholder')).map(el=>el.dataset.tabId).filter(Boolean);
    const { tabs } = getState();
    const map = new Map(tabs.map(t=>[t.id, t]));
    const next = ids.map((id,i)=>({ ...map.get(id), order: i*10 })).filter(Boolean);
    window.cloudReorderNotesTabs && await window.cloudReorderNotesTabs(next);

    dragFromId = null;
    draggingEl = null;
    placeholderEl = null;
  }

  tabsContainer.addEventListener('drop', async (e)=>{
    if(!editMode) return;
    e.preventDefault();
    await finalizeReorder();
  });

  tabsContainer.addEventListener('dragend', async ()=>{
    if(!editMode) return;
    // If dropped outside, still finalize to clean placeholder
    if(placeholderEl && draggingEl){
      await finalizeReorder();
    }
  });

  // Add tab
  if(addTabBtn){
    addTabBtn.addEventListener('click', async ()=>{
      const name = promptName('새 탭 이름', '새 탭');
      if(!name) return;
      const id = genId();
      window.cloudAddNotesTab && await window.cloudAddNotesTab({ id, name });
      await setActive(id);
    });
  }

  // Toggle edit mode
  if(toggleEditBtn){
    toggleEditBtn.addEventListener('click', ()=>{
      editMode = !editMode;
      render();
    });
  }

  // Save note content (tab-safe)
// - 입력 시점의 tabId/value를 캡처하여 저장(탭 전환 중 덮어쓰기/유실 방지)
// - 로컬 캐시(window.__notesTabs)도 즉시 갱신하여 탭 전환 시 내용 유지
if(notesArea){
  const syncLocal = ()=>{
    const tabId = window.__notesActiveTabId || 'memo';
    window.__notesTabs = window.__notesTabs || {};
    window.__notesTabs[tabId] = notesArea.value ?? '';
    return { tabId, value: window.__notesTabs[tabId] };
  };

  notesArea.addEventListener('input', ()=>{
    const { tabId, value } = syncLocal();
    window.cloudSaveNotesDebounced && window.cloudSaveNotesDebounced(tabId, value);
  });

  // 포커스가 빠질 때는 즉시 저장(디바운스 대기 중 유실 방지)
  notesArea.addEventListener('blur', ()=>{
    const { tabId, value } = syncLocal();
    window.cloudSaveNotesFor && window.cloudSaveNotesFor(tabId, value);
  });
}
// Expose renderer for realtime updates
  window.renderNotesUI = render;

  // Initial render
  render();
}


function initBookmarks(){

  const imageGrid=document.getElementById('image-grid');

  window.renderImageBookmarks=function(){

    if(!imageGrid) return;

    imageGrid.innerHTML='';

    (window.imageBookmarks||[]).forEach(d=>{
      const card=document.createElement('div');
      card.className='bookmark-card';
      card.innerHTML=`
        <div class="content">
          <div style="padding:20px;text-align:center;">
            ${d.sourceDomain||'Bookmark'}
          </div>
        </div>
      `;
      imageGrid.appendChild(card);
    });
  }

  renderImageBookmarks();
}


// ===== Inlined main.js =====
    // [수정 2] Firebase Storage 모듈 임포트
    import { 
      getStorage, 
      ref, 
      uploadBytes, 
      getDownloadURL, 
      deleteObject 
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";
    // Firebase Config (***이 부분이 수정되었습니다***)
    const firebaseConfig = {
      apiKey: "AIzaSyCiwzde40jsz17CEz-rrMmmBrn-S6brdlE",
      authDomain: "comicschedule-dfec7.firebaseapp.com",
      projectId: "comicschedule-dfec7",
      storageBucket: "comicschedule-dfec7.firebasestorage.app", // <-- 올바른 주소
      messagingSenderId: "1004611276816", // <-- 사용자님이 주신 새 ID
      appId: "1:1004611276816:web:aca83237bafa971ed1fa95", // <-- 사용자님이 주신 새 ID
      measurementId: "G-ZNZZQRJZF9"
    };

    // ***이 부분이 수정되었습니다 (analytics 관련 코드 제거, 원본 코드로 복구)***
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const storage = getStorage(app); 

    const signInBtn=document.getElementById('signInBtn');
    const signOutBtn=document.getElementById('signOutBtn');
    const userInfoEl=document.getElementById('userInfo');
    const loadingOverlay=document.getElementById('loading-overlay');
    const provider = new GoogleAuthProvider();
    
    // **도메인 추출 함수를 모듈 스코프에서 사용 가능하도록 재정의**
    function extractDomain(url) {
        if (!url) return 'Unknown';
        try {
            const urlObj = new URL(url.includes('://') ? url : 'https://' + url);
            let domain = urlObj.hostname;
            if (domain.startsWith('www.')) domain = domain.substring(4);
            return domain;
        } catch {
            return 'Unknown';
        }
    }


    async function doSignIn(){
      try{ await signInWithPopup(auth,provider); }
      catch(e){
        if(e.code==='auth/popup-blocked'||e.code==='auth/unauthorized-domain'){ await signInWithRedirect(auth,provider); }
        else{ document.getElementById('modal-message').textContent='로그인 오류: '+(e.message||e.code); document.getElementById('alert-modal').classList.remove('hidden'); }
      }
    }
    getRedirectResult(auth).catch(()=>{});

    signInBtn.onclick=()=>doSignIn();
    signOutBtn.onclick=()=>signOut(auth);

    window.cloudRefs=async ()=>{
      const uid=auth.currentUser.uid;
      const userPath=`users/${uid}`;
      return {
        tasksCol: collection(db, `${userPath}/customTasks`),
        stateDoc: doc(db, `${userPath}/meta/appState`),
        imagesCol: collection(db, `${userPath}/images`), // 이미지/동영상/링크 북마크 통합 컬렉션
      };
    };

    window.ensureLogin=()=>{
      if(!window.isAuthReady){ document.getElementById('modal-message').textContent='데이터 로딩 중입니다.'; document.getElementById('alert-modal').classList.remove('hidden'); return false; }
      if(!auth.currentUser){ document.getElementById('modal-message').textContent='로그인 후 이용해 주세요.'; document.getElementById('alert-modal').classList.remove('hidden'); return false; }
      return true;
    };

    let notesTimer=null;
    let notesPending=null; // {tabId, value}
    window.cloudSaveNotesDebounced=function(tabId, value){
      clearTimeout(notesTimer);
      // 캡처된 값이 들어오면 그 값을 우선 저장(탭 전환 중 덮어쓰기 방지)
      if(tabId){ notesPending = { tabId, value: value ?? '' }; }
      notesTimer=setTimeout(()=>{
        if(window.cloudSaveNotesFor && notesPending){
          window.cloudSaveNotesFor(notesPending.tabId, notesPending.value);
          notesPending=null;
        }else if(window.cloudSaveNotes){
          window.cloudSaveNotes();
        }
      },800);
    };

    window.cloudSaveAll=async ()=>{
      if(!ensureLogin()) return;
      const { tasksCol, stateDoc } = await cloudRefs();
      window.taskStatus=window.taskStatus||{}; window.customTasks=window.customTasks||[];
      await setDoc(stateDoc,{taskStatus:window.taskStatus},{merge:true});
      // FireStore에서 setDoc은 문서 ID가 없으면 생성, 있으면 덮어쓰기/병합하므로 map/reduce 대신 setDoc 사용
      const ops=window.customTasks.map(t=>setDoc(doc(tasksCol,String(t.id)),t,{merge:true}));
      await Promise.all(ops);
    };

    window.cloudSaveStateOnly=async ()=>{
      if(!ensureLogin()) return;
      const { stateDoc } = await cloudRefs();
      window.taskStatus=window.taskStatus||{};
      await setDoc(stateDoc,{taskStatus:window.taskStatus},{merge:true});
    };

    window.cloudSaveNotes=async (tabIdArg, valueArg)=>{
      if(!ensureLogin()) return;
      const { stateDoc } = await cloudRefs();
      const st=await getDoc(stateDoc);
      const prev=st.exists()?(st.data()||{}):{};

      // 반드시 새 객체로 복사해서 저장 (참조 공유로 인한 예기치 않은 동기화 방지)
      const notesTabs = { ...(prev.notesTabs || {}) };

      // 저장 대상 탭 결정: 인자로 들어온 tabId를 우선
      const activeId = tabIdArg || window.__notesActiveTabId || prev.notesActiveTabId || 'memo';

      // 저장 값 결정: 인자로 들어온 value를 우선, 아니면 textarea 값
      let nextValue = (valueArg !== undefined) ? valueArg : undefined;
      if(nextValue === undefined){
        const notesAreaEl=document.getElementById('notesArea');
        if(notesAreaEl) nextValue = notesAreaEl.value ?? '';
        else nextValue = '';
      }

      notesTabs[activeId] = nextValue;

      // 로컬 캐시도 동일하게 맞춰둠(탭 전환 시 내용 유지)
      window.__notesTabs = window.__notesTabs || {};
      window.__notesTabs[activeId] = nextValue;

      await setDoc(stateDoc,{notesTabs, notesActiveTabId: activeId},{merge:true});
    };

    // 명시적으로 특정 탭을 저장하는 래퍼(탭 전환/디바운스에서 사용)
    window.cloudSaveNotesFor = async (tabId, value)=>{
      return window.cloudSaveNotes(tabId, value);
    };

    // 메모 탭 CRUD (stateDoc 내부 notesTabList / notesTabs 사용)
    window.cloudSetActiveNotesTab = async (tabId)=>{
      if(!ensureLogin()) return;
      const { stateDoc } = await cloudRefs();
      await setDoc(stateDoc,{ notesActiveTabId: tabId },{ merge:true });
    };

    window.cloudAddNotesTab = async ({id, name})=>{
      if(!ensureLogin()) return;
      const { stateDoc } = await cloudRefs();
      const st=await getDoc(stateDoc);
      const prev=st.exists()?(st.data()||{}):{};
      const list = Array.isArray(prev.notesTabList) ? prev.notesTabList : [];
      const maxOrder = list.reduce((m,t)=>Math.max(m, Number(t.order||0)), 0);
      const next = [...list, { id, name, order: maxOrder + 10 }];
      await setDoc(stateDoc,{ notesTabList: next, notesActiveTabId: id },{ merge:true });
    };

    window.cloudRenameNotesTab = async (tabId, newName)=>{
      if(!ensureLogin()) return;
      const { stateDoc } = await cloudRefs();
      const st=await getDoc(stateDoc);
      const prev=st.exists()?(st.data()||{}):{};
      const list = Array.isArray(prev.notesTabList) ? prev.notesTabList : [];
      const next = list.map(t=> t.id===tabId ? ({...t, name:newName}) : t);
      await setDoc(stateDoc,{ notesTabList: next },{ merge:true });
    };

    window.cloudReorderNotesTabs = async (orderedList)=>{
      if(!ensureLogin()) return;
      const { stateDoc } = await cloudRefs();
      // orderedList는 [{id,name,order},...] 형태
      await setDoc(stateDoc,{ notesTabList: orderedList },{ merge:true });
    };

    window.cloudDeleteNotesTab = async (tabId)=>{
      if(!ensureLogin()) return;
      const { stateDoc } = await cloudRefs();
      const st=await getDoc(stateDoc);
      const prev=st.exists()?(st.data()||{}):{};
      const list = Array.isArray(prev.notesTabList) ? prev.notesTabList : [];
      const notesTabs = prev.notesTabs || {};
      const nextList = list.filter(t=>t.id!==tabId);
      const nextNotes = {...notesTabs};
      delete nextNotes[tabId];

      // 최소 1개 탭 유지 (없어지면 기본 '메모' 생성)
      let nextActive = prev.notesActiveTabId || window.__notesActiveTabId || 'memo';
      if(nextActive===tabId){
        nextActive = nextList[0]?.id || 'memo';
      }
      if(nextList.length===0){
        nextList.push({ id:'memo', name:'메모', order:0 });
        nextActive = 'memo';
        // 기본 탭은 빈 메모
        nextNotes['memo'] = nextNotes['memo'] || '';
      }

      await setDoc(stateDoc,{ notesTabList: nextList, notesTabs: nextNotes, notesActiveTabId: nextActive },{ merge:true });
    };

    window.deleteTask=async ()=>{
      if(!ensureLogin() || !window.currentTask?.id){ if(typeof closeModal==='function') closeModal(); return; }
      const { tasksCol } = await cloudRefs();
      await deleteDoc(doc(tasksCol,String(window.currentTask.id)));
      window.customTasks=(window.customTasks||[]).filter(t=>t.id!==window.currentTask.id);
      if(typeof renderCalendar==='function') renderCalendar();
    };

    // ===== 북마크 저장 로직 (sourceDomain 추가) =====
    
    
    
    // 일반 링크 북마크 저장 (URL만 저장, type: 'link')
    window.addGenericBookmark = async (url)=>{
      if(!ensureLogin()) return;
      const { imagesCol } = await cloudRefs();
      // pageUrl 필드에 일반 URL을 저장. title 필드 추가.
      await addDoc(imagesCol,{ pageUrl: url, url: null, type:'link', title: null, sourceDomain: extrac
// 이미지 URL만 저장 (type: 'remote')
    window.addRemoteImage = async (url, pageUrl)=>{
      if(!ensureLogin()) return;
      const { imagesCol } = await cloudRefs();
      await addDoc(imagesCol,{ url, pageUrl: pageUrl||null, type:'remote', sourceDomain: extractDomain(pageUrl || url), timestamp:new Date() });
    };
    
    // [수정 4] window.addImage 함수 전체 교체 ( -> Firebase Storage)
    // (붙여넣기/클립보드/파일드래그 이미지 전용)
    window.addImage = async (file, pageUrl)=>{ // 'fileOrUrl'을 'file'로 명시
      if(!ensureLogin()) return;

      // file이 string으로 들어오는 경우 (현재 UI에서는 사용되지 않음)
      if (typeof file === 'string') {
          // 원본 URL 추가 로직으로 연결
          return window.addRemoteImage(file, pageUrl || file);
      }
      
      // file이 File 객체인 경우 (주요 사용 사례)
      try{
        const { imagesCol } = await cloudRefs();
        const user = auth.currentUser;
        if (!user) throw new Error("로그인이 필요합니다.");

        // 1. 고유한 파일 경로 생성
        const storagePath = `users/${user.uid}/uploads/${Date.now()}_${file.name}`;
        const storageRef = ref(storage, storagePath);

        // 2. 파일 업로드 (피드백 메시지 추가)
        showFeedbackMessage('이미지 업로드 중...');
        const uploadResult = await uploadBytes(storageRef, file);
        
        // 3. 다운로드 URL 가져오기
        const downloadURL = await getDownloadURL(uploadResult.ref);
        
        const source = pageUrl ? extractDomain(pageUrl) : 'Uploaded (Firebase)';

        // 4. Firestore에 정보 저장
        await addDoc(imagesCol,{ 
          url: downloadURL,       // Firebase Storage URL
          pageUrl: pageUrl || null,
          type: 'firebase_storage', //  대신 새 타입 지정
          storagePath: storagePath, // [중요] 삭제를 위한 파일 경로 저장
          title: null, 
          sourceDomain: source, 
          timestamp: new Date() 
        });
        showFeedbackMessage('이미지가 업로드되었습니다.'); // 성공 피드백

      }catch(err){
        console.error("Firebase Storage 업로드 실패:", err);
        document.getElementById('modal-message').textContent='이미지 추가 실패: '+(err.message||'오류');
        document.getElementById('alert-modal').classList.remove('hidden');
      }
    };

    // 북마크 제목 수정 기능 (신규)
        try {
            await updateDoc(docRef, { title: newTitle || null });
        } catch (e) {
            console.error("제목 업데이트 오류:", e);
            showAlert("제목을 저장하는 중 오류가 발생했습니다.");
        }
    };

    // 링크 북마크 미리보기 이미지 업로드 (붙여넣기 전용)
    // - Firebase Storage에 업로드 후, 해당 북마크 문서에 previewImageUrl 저장
    // - 기존 preview는 유지(이전 파일 삭제하지 않음)
        const { imagesCol } = await cloudRefs();
        const user = auth.currentUser;
        if(!user) throw new Error('로그인이 필요합니다.');

        // 파일명/타입 보정
        const contentType = file.type || 'image/png';
        const safeName = (file.name && file.name.trim()) ? file.name : `preview_${bookmarkId}.png`;
        const storagePath = `users/${user.uid}/uploads/bookmark_preview_${bookmarkId}_${Date.now()}_${safeName}`;
        const storageRef = ref(storage, storagePath);

        const uploadResult = await uploadBytes(storageRef, file, { contentType });
        const downloadURL = await getDownloadURL(uploadResult.ref);

        const docRef = doc(imagesCol, bookmarkId);
        await updateDoc(docRef, { previewImageUrl: downloadURL, previewStoragePath: storagePath });
    };


    // [수정 5] window.deleteImage 함수 전체 교체 (Firebase Storage 삭제 로직 추가)
    window.deleteImage = async (id)=>{
      if(!ensureLogin()) return;
      try{
        const { imagesCol } = await cloudRefs();
        const row=(window.imageBookmarks||[]).find(d=>d.id===id);
        if(!row) throw new Error('북마크 항목을 찾을 수 없습니다.');

        // Firebase Storage 업로드 이미지인 경우: 스토리지 파일 삭제 후 문서 삭제
        if(row.type === 'firebase_storage' && row.storagePath){
          try{
            const fileRef = ref(storage, row.storagePath);
            await deleteObject(fileRef);
          }catch(e){
            console.warn('Storage 파일 삭제 실패 (무시함):', e);
          }
        }

        // Firestore 문서 삭제 (링크/원격이미지 포함)
        await deleteDoc(doc(imagesCol, id));
        showFeedbackMessage('북마크가 삭제되었습니다.');
      }catch(e){
        document.getElementById('modal-message').textContent='북마크 삭제 중 오류: '+(e?.message||'unknown');
        document.getElementById('alert-modal').classList.remove('hidden');
      }
    };

    // ===== 실시간 동기화 =====
    window.__unsubs=[];
    async function setupRealtimeSync(){
      const { tasksCol, stateDoc, imagesCol } = await cloudRefs();

      // ===== 메모 탭 스키마 초기화 (기존 메모/탭을 정리하고 '메모' 탭 1개로 시작) =====
      try{
        const st=await getDoc(stateDoc);
        const prev=st.exists()?(st.data()||{}):{};
        const ver = Number(prev.notesSchemaVersion || 0);
        if(ver < 2){
          // 기존 메모 정리(요청사항: 깔끔하게 초기화)
          const defaultTabs=[{ id:'memo', name:'메모', order:0 }];
          await setDoc(stateDoc,{
            notesSchemaVersion: 2,
            notesTabList: defaultTabs,
            notesTabs: { memo: '' },
            notesActiveTabId: 'memo'
          },{ merge:true });
        }
      }catch(_){}

      window.__unsubs.forEach(fn=>{ try{ fn(); }catch(_){} }); window.__unsubs=[];

      const unsubTasks = onSnapshot(tasksCol,(snap)=>{ window.customTasks=snap.docs.map(d=>({id:d.id,...d.data()})); if(typeof renderCalendar==='function') renderCalendar(); });
      window.__unsubs.push(unsubTasks);

      const unsubState = onSnapshot(stateDoc,(ds)=>{
        const data=ds.exists()?(ds.data()||{}):{};
        window.taskStatus=data.taskStatus||{};
        window.__notesTabList = Array.isArray(data.notesTabList) && data.notesTabList.length ? data.notesTabList : [{ id:'memo', name:'메모', order:0 }];
        window.__notesTabs = data.notesTabs || {};
        window.__notesActiveTabId = data.notesActiveTabId || window.__notesActiveTabId || 'memo';
        if(typeof window.renderNotesUI==='function') window.renderNotesUI();
        if(typeof renderCalendar==='function') renderCalendar();
      });
      window.__unsubs.push(unsubState);

      const unsubImages = onSnapshot(imagesCol,(snap)=>{ 
          // imageBookmarks에 이미지/링크 북마크 포함
          window.imageBookmarks=snap.docs.map(d=>({id:d.id,...d.data()})); 
          if(typeof renderImageBookmarks==='function') renderImageBookmarks(); 
      });
      window.__unsubs.push(unsubImages);
    }

    onAuthStateChanged(auth, async (user)=>{
      loadingOverlay.classList.remove('hidden'); window.isAuthReady=false;
      if(user){
        userInfoEl.textContent = `${user.displayName || '로그인됨'} (${user.email || ''})`;
        signInBtn.classList.add('hidden');
        signOutBtn.classList.remove('hidden');
        await setupRealtimeSync();
      }else{
        userInfoEl.textContent=''; signOutBtn.classList.add('hidden'); signInBtn.classList.remove('hidden');
        window.__unsubs.forEach(fn=>{ try{ fn(); }catch(_){} }); window.__unsubs=[];
        window.customTasks=[]; window.taskStatus={}; window.imageBookmarks=[]; window.__notesTabs={}; window.__notesTabList=[{id:'memo',name:'메모',order:0}]; window.__notesActiveTabId='memo';
        if(typeof renderCalendar==='function') renderCalendar(); if(typeof renderImageBookmarks==='function') renderImageBookmarks(); const na=document.getElementById('notesArea'); if(na) na.value='';
      }
      loadingOverlay.classList.add('hidden'); window.isAuthReady=true;
    });

initCalendar();
initNotes();
initBookmarks();

</script>


</body>
</html>